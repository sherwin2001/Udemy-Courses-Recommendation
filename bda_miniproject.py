# -*- coding: utf-8 -*-
"""BDA_Miniproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f1iido_TOKgIoLZR50Rugs3xqgW6asjI
"""

!pip install streamlit

!pip install pyngrok

from google.colab import drive
drive.mount('/content/drive')

Commented out IPython magic to ensure Python compatibility.
%%writefile app.py
# Core Pkg
import streamlit as st 
import streamlit.components.v1 as stc 


# Load EDA
import pandas as pd 
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity,linear_kernel


# Load Our Dataset
def load_data(data):
	df = pd.read_csv(data)
	return df 


# Fxn
# Vectorize + Cosine Similarity Matrix

def vectorize_text_to_cosine_mat(data):
	count_vect = CountVectorizer()
	cv_mat = count_vect.fit_transform(data)
	# Get the cosine
	cosine_sim_mat = cosine_similarity(cv_mat)
	return cosine_sim_mat



# Recommendation Sys
@st.cache
def get_recommendation(title,cosine_sim_mat,df,num_of_rec=10):
	# indices of the course
	course_indices = pd.Series(df.index,index=df['course_title']).drop_duplicates()
	# Index of course
	idx = course_indices[title]

	# Look into the cosine matr for that index
	sim_scores =list(enumerate(cosine_sim_mat[idx]))
	sim_scores = sorted(sim_scores,key=lambda x: x[1],reverse=True)
	selected_course_indices = [i[0] for i in sim_scores[1:]]
	selected_course_scores = [i[0] for i in sim_scores[1:]]

	# Get the dataframe & title
	result_df = df.iloc[selected_course_indices]
	result_df['similarity_score'] = selected_course_scores
	final_recommended_courses = result_df[['course_title','similarity_score','url','price','num_subscribers']]
	return final_recommended_courses.head(num_of_rec)


RESULT_TEMP = """
<div style="width:90%;height:100%;margin:1px;padding:5px;position:relative;border-radius:5px;border-bottom-right-radius: 60px;
box-shadow:0 0 15px 5px #ccc; background-image: url('https://www.professionalcontentcreation.com/wp-content/uploads/2016/05/top-10-udemy-courses-for-writers-1.jpg');
  border-left: 5px solid #6c6c6c;">
<h4>{}</h4>
<p style="color:blue;"><span style="color:black;">ğŸ“ˆScore::</span>{}</p>
<p style="color:blue;"><span style="color:black;">ğŸ”—</span><a href="{}",target="_blank">Link</a></p>
<p style="color:blue;"><span style="color:black;">ğŸ’²Price:</span>{}</p>
<p style="color:blue;"><span style="color:black;">ğŸ§‘â€ğŸ“ğŸ‘¨ğŸ½â€ğŸ“ Students:</span>{}</p>

</div>
"""

# Search For Course 
@st.cache
def search_term_if_not_found(term,df):
	result_df = df[df['course_title'].str.contains(term)]
	return result_df


def main():

	st.title("Course Recommendation App")

	menu = ["Home","Recommend","About"]
	choice = st.sidebar.selectbox("Menu",menu)

	df = load_data('/content/drive/MyDrive/Data/udemy_course_data.csv')

	if choice == "Home":
		st.subheader("Home")
		st.dataframe(df.head(20))


	elif choice == "Recommend":
		st.subheader("Recommend Courses")
		cosine_sim_mat = vectorize_text_to_cosine_mat(df['course_title'])
		search_term = st.text_input("Search")
		num_of_rec = st.sidebar.number_input("Number",4,30,7)
		if st.button("Recommend"):
			if search_term is not None:
				try:
					results = get_recommendation(search_term,cosine_sim_mat,df,num_of_rec)
					with st.expander("Results as JSON"):
						results_json = results.to_dict('index')
						st.write(results_json)

					for row in results.iterrows():
						rec_title = row[1][0]
						rec_score = row[1][1]
						rec_url = row[1][2]
						rec_price = row[1][3]
						rec_num_sub = row[1][4]

						# st.write("Title",rec_title,)
						stc.html(RESULT_TEMP.format(rec_title,rec_score,rec_url,rec_url,rec_num_sub),height=350)
				except:
					results= "Course Not Found			OR			If you are using keywords instead of proper course name you won't get recommendations similar to the courses you have joined."
					st.warning(results)
					st.info("Suggested Options Include")
					result_df = search_term_if_not_found(search_term,df)
					st.dataframe(result_df)


	else:
		st.subheader("About")
		st.text("Course Recommendation System App basically aims at recommending courses that are")
		st.text(" similar to those that you have completed or joined.")
		st.text("To find recommendations one needs to specify the correct name of their course.") 
		st.text("If one uses keywords, only suggestions related to the search term will be displayed.") 
		st.text("The user can then copy course name of their choice from there and find") 
		st.text("recommendations related to it.")


if __name__ == '__main__':
	main()




# !ngrok authtoken 1z4MhgcBk8pUGAce0UYFvW99zyf_2Ks39WFUmAFNqnqWbi2Pi

# !ngrok

# from pyngrok import ngrok

# !streamlit run --server.port 80 app.py&>/dev/null&

# !pgrep streamlit

# public_url = ngrok.connect(port='80')

# public_url